package selfservice

import (
	"bytes"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"image/png"
	"math/rand"
	"time"

	"github.com/bufbuild/connect-go"
	"github.com/pquerna/otp/totp"
	idmv1 "github.com/tierklinik-dobersberg/apis/gen/go/tkd/idm/v1"
	"github.com/tierklinik-dobersberg/cis-idm/internal/middleware"
	"github.com/tierklinik-dobersberg/cis-idm/internal/repo/stmts"
	"github.com/vincent-petithory/dataurl"
	"golang.org/x/crypto/bcrypt"
)

func (svc *Service) ChangePassword(ctx context.Context, req *connect.Request[idmv1.ChangePasswordRequest]) (*connect.Response[idmv1.ChangePasswordResponse], error) {
	claims := middleware.ClaimsFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("no claims associated with request context")
	}

	user, err := svc.Datastore.GetUserByID(ctx, claims.Subject)
	if err != nil {
		return nil, fmt.Errorf("failed to get user object: %w", err)
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Msg.GetOldPassword())); err != nil {
		return nil, connect.NewError(connect.CodePermissionDenied, fmt.Errorf("incorrect password"))
	}

	newHashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Msg.GetNewPassword()), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to generate password hash: %w", err)
	}

	if err := svc.Datastore.SetUserPassword(ctx, claims.Subject, string(newHashedPassword)); err != nil {
		return nil, fmt.Errorf("failed to save user password: %w", err)
	}

	return connect.NewResponse(&idmv1.ChangePasswordResponse{}), nil
}

func (svc *Service) Enroll2FA(ctx context.Context, req *connect.Request[idmv1.Enroll2FARequest]) (*connect.Response[idmv1.Enroll2FAResponse], error) {
	claims := middleware.ClaimsFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("no token claims associated with request context")
	}

	user, err := svc.Datastore.GetUserByID(ctx, claims.Subject)
	if err != nil {
		return nil, err
	}

	switch v := req.Msg.Kind.(type) {
	case *idmv1.Enroll2FARequest_TotpStep1:
		if user.TOTPSecret != "" {
			return nil, connect.NewError(connect.CodeAlreadyExists, fmt.Errorf("totp already enrolled"))
		}

		displayName := user.DisplayName
		if displayName == "" {
			displayName = user.Username
		}

		key, err := totp.Generate(totp.GenerateOpts{
			Issuer:      svc.Config.SiteName,
			AccountName: displayName,
		})
		if err != nil {
			return nil, err
		}

		mac := hmac.New(sha256.New, []byte(svc.Config.JWTSecret))

		macString := mac.Sum([]byte(key.Secret()))
		macStringHex := hex.EncodeToString(macString)

		img, err := key.Image(200, 200)
		if err != nil {
			return nil, err
		}

		var buf bytes.Buffer
		if err := png.Encode(&buf, img); err != nil {
			return nil, err
		}

		dataUrl := dataurl.EncodeBytes(buf.Bytes())

		return connect.NewResponse(&idmv1.Enroll2FAResponse{
			Kind: &idmv1.Enroll2FAResponse_TotpStep1{
				TotpStep1: &idmv1.EnrollTOTPResponseStep1{
					Secret:     key.Secret(),
					SecretHmac: macStringHex,
					QrCode:     dataUrl,
					Url:        key.String(),
				},
			},
		}), nil

	case *idmv1.Enroll2FARequest_TotpStep2:
		if user.TOTPSecret != "" {
			return nil, connect.NewError(connect.CodeAlreadyExists, fmt.Errorf("totp already enrolled"))
		}

		// verify that the secret sent in the request was generated by us
		mac := hmac.New(sha256.New, []byte(svc.Config.JWTSecret))
		macString := mac.Sum([]byte(v.TotpStep2.Secret))
		macStringHex := hex.EncodeToString(macString)
		if macStringHex != v.TotpStep2.SecretHmac {
			return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid secret"))
		}

		// validate the TOTP passcode
		valid := totp.Validate(v.TotpStep2.VerifyCode, v.TotpStep2.Secret)
		if !valid {
			return nil, fmt.Errorf("invalid passcode")
		}

		if err := svc.Datastore.SetUserTotpSecret(ctx, claims.Subject, v.TotpStep2.Secret); err != nil {
			return nil, err
		}

		return connect.NewResponse(&idmv1.Enroll2FAResponse{
			Kind: &idmv1.Enroll2FAResponse_TotpStep2{},
		}), nil

	default:
		return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("requested mfa kind is not available"))
	}
}

func (svc *Service) Remove2FA(ctx context.Context, req *connect.Request[idmv1.Remove2FARequest]) (*connect.Response[idmv1.Remove2FAResponse], error) {
	claims := middleware.ClaimsFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("no token claims associated with request context")
	}

	user, err := svc.Datastore.GetUserByID(ctx, claims.Subject)
	if err != nil {
		return nil, err
	}

	switch v := req.Msg.Kind.(type) {
	case *idmv1.Remove2FARequest_TotpCode:
		if user.TOTPSecret == "" {
			return nil, connect.NewError(connect.CodeFailedPrecondition, fmt.Errorf("totp 2fa not enrooled"))
		}

		valid := totp.Validate(v.TotpCode, user.TOTPSecret)
		if !valid {
			// check if the user used a recovery code
			recoveryCodeErr := svc.Datastore.CheckAndDeleteRecoveryCode(ctx, user.ID, v.TotpCode)
			if recoveryCodeErr != nil {
				if errors.Is(recoveryCodeErr, stmts.ErrNoRowsAffected) {
					return nil, connect.NewError(connect.CodeFailedPrecondition, fmt.Errorf("totp passcode invalid"))
				}

				return nil, recoveryCodeErr
			}
		}

		if err := svc.Datastore.RemoveUserTotpSecret(ctx, claims.Subject); err != nil {
			return nil, err
		}

	default:
		return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("unsupported mfa type"))
	}

	return connect.NewResponse(&idmv1.Remove2FAResponse{}), nil
}

func (svc *Service) GenerateRecoveryCodes(ctx context.Context, req *connect.Request[idmv1.GenerateRecoveryCodesRequest]) (*connect.Response[idmv1.GenerateRecoveryCodesResponse], error) {
	claims := middleware.ClaimsFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("no token claims associated with request context")
	}

	source := rand.NewSource(time.Now().UnixNano())
	rand := rand.New(source)

	codes := make([]string, 20)
	for i := range codes {
		codes[i] = fmt.Sprintf("%d", rand.Intn(999999-100000)+100000)
	}

	if err := svc.Datastore.ReplaceUserRecoveryCodes(ctx, claims.Subject, codes); err != nil {
		return nil, err
	}

	return connect.NewResponse(&idmv1.GenerateRecoveryCodesResponse{
		RecoveryCodes: codes,
	}), nil
}
