// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package repo

import (
	"context"
)

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*)
FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
    users (
        id,
        username,
        display_name,
        first_name,
        last_name,
        extra,
        avatar,
        birthday,
        password
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, username, display_name, first_name, last_name, extra, avatar, birthday, password, totp_secret, deleted
`

type CreateUserParams struct {
	ID          string
	Username    string
	DisplayName string
	FirstName   string
	LastName    string
	Extra       string
	Avatar      string
	Birthday    string
	Password    string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.Username,
		arg.DisplayName,
		arg.FirstName,
		arg.LastName,
		arg.Extra,
		arg.Avatar,
		arg.Birthday,
		arg.Password,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.DisplayName,
		&i.FirstName,
		&i.LastName,
		&i.Extra,
		&i.Avatar,
		&i.Birthday,
		&i.Password,
		&i.TotpSecret,
		&i.Deleted,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :execrows
UPDATE
    users
SET
    deleted = true
WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteUser, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT
    id, username, display_name, first_name, last_name, extra, avatar, birthday, password, totp_secret, deleted
FROM
    users
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.DisplayName,
			&i.FirstName,
			&i.LastName,
			&i.Extra,
			&i.Avatar,
			&i.Birthday,
			&i.Password,
			&i.TotpSecret,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEMail = `-- name: GetUserByEMail :one
SELECT
    users.id, users.username, users.display_name, users.first_name, users.last_name, users.extra, users.avatar, users.birthday, users.password, users.totp_secret, users.deleted,
    user_emails.verified
FROM
    users
    JOIN user_emails ON user_emails.user_id = users.id
WHERE
    user_emails.address = ?
`

type GetUserByEMailRow struct {
	User     User
	Verified bool
}

func (q *Queries) GetUserByEMail(ctx context.Context, address string) (GetUserByEMailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEMail, address)
	var i GetUserByEMailRow
	err := row.Scan(
		&i.User.ID,
		&i.User.Username,
		&i.User.DisplayName,
		&i.User.FirstName,
		&i.User.LastName,
		&i.User.Extra,
		&i.User.Avatar,
		&i.User.Birthday,
		&i.User.Password,
		&i.User.TotpSecret,
		&i.User.Deleted,
		&i.Verified,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    id, username, display_name, first_name, last_name, extra, avatar, birthday, password, totp_secret, deleted
FROM
    users
WHERE
    id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.DisplayName,
		&i.FirstName,
		&i.LastName,
		&i.Extra,
		&i.Avatar,
		&i.Birthday,
		&i.Password,
		&i.TotpSecret,
		&i.Deleted,
	)
	return i, err
}

const getUserByName = `-- name: GetUserByName :one
SELECT
    id, username, display_name, first_name, last_name, extra, avatar, birthday, password, totp_secret, deleted
FROM
    users
WHERE
    username = ?
`

func (q *Queries) GetUserByName(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByName, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.DisplayName,
		&i.FirstName,
		&i.LastName,
		&i.Extra,
		&i.Avatar,
		&i.Birthday,
		&i.Password,
		&i.TotpSecret,
		&i.Deleted,
	)
	return i, err
}

const setUserExtraData = `-- name: SetUserExtraData :execrows
UPDATE users
SET extra = ?
WHERE id = ?
`

type SetUserExtraDataParams struct {
	Extra string
	ID    string
}

func (q *Queries) SetUserExtraData(ctx context.Context, arg SetUserExtraDataParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, setUserExtraData, arg.Extra, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET
			username = ?,
			display_name = ?,
			first_name = ?,
			last_name = ?,
			extra = ?,
			avatar = ?,
			birthday = ?
		WHERE id = ?
        RETURNING id, username, display_name, first_name, last_name, extra, avatar, birthday, password, totp_secret, deleted
`

type UpdateUserParams struct {
	Username    string
	DisplayName string
	FirstName   string
	LastName    string
	Extra       string
	Avatar      string
	Birthday    string
	ID          string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Username,
		arg.DisplayName,
		arg.FirstName,
		arg.LastName,
		arg.Extra,
		arg.Avatar,
		arg.Birthday,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.DisplayName,
		&i.FirstName,
		&i.LastName,
		&i.Extra,
		&i.Avatar,
		&i.Birthday,
		&i.Password,
		&i.TotpSecret,
		&i.Deleted,
	)
	return i, err
}
