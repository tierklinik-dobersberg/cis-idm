// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: token.sql

package repo

import (
	"context"
	"database/sql"
	"time"
)

const checkAndDeleteRecoveryCode = `-- name: CheckAndDeleteRecoveryCode :execrows
DELETE FROM
	mfa_backup_codes
WHERE
	user_id = ?
	AND code = ?
`

type CheckAndDeleteRecoveryCodeParams struct {
	UserID string
	Code   string
}

func (q *Queries) CheckAndDeleteRecoveryCode(ctx context.Context, arg CheckAndDeleteRecoveryCodeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, checkAndDeleteRecoveryCode, arg.UserID, arg.Code)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createRegistrationToken = `-- name: CreateRegistrationToken :exec
INSERT INTO
	registration_tokens (
		token,
		expires,
		allowed_usage,
		initial_roles,
		created_by,
		created_at
	)
VALUES
	(?, ?, ?, ?, ?, ?)
`

type CreateRegistrationTokenParams struct {
	Token        string
	Expires      sql.NullTime
	AllowedUsage sql.NullInt64
	InitialRoles string
	CreatedBy    string
	CreatedAt    time.Time
}

func (q *Queries) CreateRegistrationToken(ctx context.Context, arg CreateRegistrationTokenParams) error {
	_, err := q.db.ExecContext(ctx, createRegistrationToken,
		arg.Token,
		arg.Expires,
		arg.AllowedUsage,
		arg.InitialRoles,
		arg.CreatedBy,
		arg.CreatedAt,
	)
	return err
}

const createRejectedToken = `-- name: CreateRejectedToken :exec
INSERT INTO
	token_invalidation (token_id, user_id, expires_at, issued_at)
VALUES
	(?, ?, ?, ?)
`

type CreateRejectedTokenParams struct {
	TokenID   string
	UserID    string
	ExpiresAt time.Time
	IssuedAt  time.Time
}

func (q *Queries) CreateRejectedToken(ctx context.Context, arg CreateRejectedTokenParams) error {
	_, err := q.db.ExecContext(ctx, createRejectedToken,
		arg.TokenID,
		arg.UserID,
		arg.ExpiresAt,
		arg.IssuedAt,
	)
	return err
}

const deleteExpiredTokens = `-- name: DeleteExpiredTokens :execrows
DELETE FROM
	token_invalidation
WHERE
	expires_at < ?
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context, expiresAt time.Time) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteExpiredTokens, expiresAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getRegistrationToken = `-- name: GetRegistrationToken :one
SELECT
	token, expires, allowed_usage, initial_roles, created_by, created_at
FROM
	registration_tokens
WHERE
	token = ?
	AND allowed_usage > 0
	AND (
		expires IS NULL
		OR expires > ?
	)
`

type GetRegistrationTokenParams struct {
	Token   string
	Expires sql.NullTime
}

func (q *Queries) GetRegistrationToken(ctx context.Context, arg GetRegistrationTokenParams) (RegistrationToken, error) {
	row := q.db.QueryRowContext(ctx, getRegistrationToken, arg.Token, arg.Expires)
	var i RegistrationToken
	err := row.Scan(
		&i.Token,
		&i.Expires,
		&i.AllowedUsage,
		&i.InitialRoles,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const insertRecoveryCodes = `-- name: InsertRecoveryCodes :exec
INSERT INTO
	mfa_backup_codes (code, user_id)
VALUES
	(?, ?)
`

type InsertRecoveryCodesParams struct {
	Code   string
	UserID string
}

func (q *Queries) InsertRecoveryCodes(ctx context.Context, arg InsertRecoveryCodesParams) error {
	_, err := q.db.ExecContext(ctx, insertRecoveryCodes, arg.Code, arg.UserID)
	return err
}

const isTokenRejected = `-- name: IsTokenRejected :one
SELECT
	COUNT(*) > 0
FROM
	token_invalidation
WHERE
	token_id = ?
`

func (q *Queries) IsTokenRejected(ctx context.Context, tokenID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isTokenRejected, tokenID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const loadUserRecoveryCodes = `-- name: LoadUserRecoveryCodes :many
SELECT
	code, user_id
FROM
	mfa_backup_codes
WHERE
	user_id = ?
`

func (q *Queries) LoadUserRecoveryCodes(ctx context.Context, userID string) ([]MfaBackupCode, error) {
	rows, err := q.db.QueryContext(ctx, loadUserRecoveryCodes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MfaBackupCode
	for rows.Next() {
		var i MfaBackupCode
		if err := rows.Scan(&i.Code, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markRegistrationTokenUsed = `-- name: MarkRegistrationTokenUsed :one
UPDATE
	registration_tokens
SET
	allowed_usage = (
		CASE
			WHEN allowed_usage IS NOT NULL THEN allowed_usage - 1
			ELSE NULL
		END
	)
WHERE
	token = ?
	AND (
		expires IS NULL
		OR expires > ?
	)
RETURNING token, expires, allowed_usage, initial_roles, created_by, created_at
`

type MarkRegistrationTokenUsedParams struct {
	Token   string
	Expires sql.NullTime
}

func (q *Queries) MarkRegistrationTokenUsed(ctx context.Context, arg MarkRegistrationTokenUsedParams) (RegistrationToken, error) {
	row := q.db.QueryRowContext(ctx, markRegistrationTokenUsed, arg.Token, arg.Expires)
	var i RegistrationToken
	err := row.Scan(
		&i.Token,
		&i.Expires,
		&i.AllowedUsage,
		&i.InitialRoles,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const removeAllRecoveryCodes = `-- name: RemoveAllRecoveryCodes :exec
DELETE FROM
	mfa_backup_codes
WHERE
	user_id = ?
`

func (q *Queries) RemoveAllRecoveryCodes(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, removeAllRecoveryCodes, userID)
	return err
}

const validateRegistrationToken = `-- name: ValidateRegistrationToken :one
SELECT
	COUNT(*) > 0
FROM
	registration_tokens
WHERE
	token = ?
`

func (q *Queries) ValidateRegistrationToken(ctx context.Context, token string) (bool, error) {
	row := q.db.QueryRowContext(ctx, validateRegistrationToken, token)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}
