// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: token.sql

package repo

import (
	"context"
	"database/sql"
	"time"
)

const addRoleToToken = `-- name: AddRoleToToken :exec
INSERT INTO user_api_token_roles (token_id, role_id) VALUES (?, ?)
`

type AddRoleToTokenParams struct {
	TokenID string
	RoleID  string
}

func (q *Queries) AddRoleToToken(ctx context.Context, arg AddRoleToTokenParams) error {
	_, err := q.db.ExecContext(ctx, addRoleToToken, arg.TokenID, arg.RoleID)
	return err
}

const checkAndDeleteRecoveryCode = `-- name: CheckAndDeleteRecoveryCode :execrows
DELETE FROM
	mfa_backup_codes
WHERE
	user_id = ?
	AND code = ?
`

type CheckAndDeleteRecoveryCodeParams struct {
	UserID string
	Code   string
}

func (q *Queries) CheckAndDeleteRecoveryCode(ctx context.Context, arg CheckAndDeleteRecoveryCodeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, checkAndDeleteRecoveryCode, arg.UserID, arg.Code)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createAPIToken = `-- name: CreateAPIToken :exec
INSERT INTO user_api_tokens (id, token, name, user_id, expires_at) VALUES (?, ?, ?, ?, ?)
`

type CreateAPITokenParams struct {
	ID        string
	Token     string
	Name      string
	UserID    string
	ExpiresAt sql.NullTime
}

func (q *Queries) CreateAPIToken(ctx context.Context, arg CreateAPITokenParams) error {
	_, err := q.db.ExecContext(ctx, createAPIToken,
		arg.ID,
		arg.Token,
		arg.Name,
		arg.UserID,
		arg.ExpiresAt,
	)
	return err
}

const createRegistrationToken = `-- name: CreateRegistrationToken :exec
INSERT INTO
	registration_tokens (
		token,
		expires,
		allowed_usage,
		initial_roles,
		created_by,
		created_at
	)
VALUES
	(?, ?, ?, ?, ?, ?)
`

type CreateRegistrationTokenParams struct {
	Token        string
	Expires      sql.NullTime
	AllowedUsage sql.NullInt64
	InitialRoles string
	CreatedBy    string
	CreatedAt    time.Time
}

func (q *Queries) CreateRegistrationToken(ctx context.Context, arg CreateRegistrationTokenParams) error {
	_, err := q.db.ExecContext(ctx, createRegistrationToken,
		arg.Token,
		arg.Expires,
		arg.AllowedUsage,
		arg.InitialRoles,
		arg.CreatedBy,
		arg.CreatedAt,
	)
	return err
}

const createRejectedToken = `-- name: CreateRejectedToken :exec
INSERT INTO
	token_invalidation (token_id, user_id, expires_at, issued_at)
VALUES
	(?, ?, ?, ?)
`

type CreateRejectedTokenParams struct {
	TokenID   string
	UserID    string
	ExpiresAt time.Time
	IssuedAt  time.Time
}

func (q *Queries) CreateRejectedToken(ctx context.Context, arg CreateRejectedTokenParams) error {
	_, err := q.db.ExecContext(ctx, createRejectedToken,
		arg.TokenID,
		arg.UserID,
		arg.ExpiresAt,
		arg.IssuedAt,
	)
	return err
}

const deleteExpiredTokens = `-- name: DeleteExpiredTokens :execrows
DELETE FROM
	token_invalidation
WHERE
	expires_at < ?
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context, expiresAt time.Time) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteExpiredTokens, expiresAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAPITokensForUser = `-- name: GetAPITokensForUser :many
SELECT id, token, name, user_id, expires_at, created_at FROM user_api_tokens WHERE user_id = ?
`

func (q *Queries) GetAPITokensForUser(ctx context.Context, userID string) ([]UserApiToken, error) {
	rows, err := q.db.QueryContext(ctx, getAPITokensForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserApiToken
	for rows.Next() {
		var i UserApiToken
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.Name,
			&i.UserID,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegistrationToken = `-- name: GetRegistrationToken :one
SELECT
	token, expires, allowed_usage, initial_roles, created_by, created_at
FROM
	registration_tokens
WHERE
	token = ?
	AND allowed_usage > 0
	AND (
		expires IS NULL
		OR expires > ?
	)
`

type GetRegistrationTokenParams struct {
	Token   string
	Expires sql.NullTime
}

func (q *Queries) GetRegistrationToken(ctx context.Context, arg GetRegistrationTokenParams) (RegistrationToken, error) {
	row := q.db.QueryRowContext(ctx, getRegistrationToken, arg.Token, arg.Expires)
	var i RegistrationToken
	err := row.Scan(
		&i.Token,
		&i.Expires,
		&i.AllowedUsage,
		&i.InitialRoles,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getRolesForToken = `-- name: GetRolesForToken :many
SELECT roles.id, roles.name, roles.description, roles.delete_protected, roles.origin
FROM user_api_tokens
JOIN user_api_token_roles ON user_api_tokens.id = user_api_token_roles.token_id
JOIN roles ON user_api_token_roles.role_id = roles.id
WHERE user_api_tokens.id = ?
`

func (q *Queries) GetRolesForToken(ctx context.Context, id string) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, getRolesForToken, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.DeleteProtected,
			&i.Origin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserForAPIToken = `-- name: GetUserForAPIToken :one
SELECT 
    users.id, users.username, users.display_name, users.first_name, users.last_name, users.extra, users.avatar, users.birthday, users.password, users.totp_secret, users.deleted,
    user_api_tokens.id, user_api_tokens.token, user_api_tokens.name, user_api_tokens.user_id, user_api_tokens.expires_at, user_api_tokens.created_at
FROM user_api_tokens
JOIN users ON user_api_tokens.user_id = users.id
WHERE user_api_tokens.token = ?
`

type GetUserForAPITokenRow struct {
	User         User
	UserApiToken UserApiToken
}

func (q *Queries) GetUserForAPIToken(ctx context.Context, token string) (GetUserForAPITokenRow, error) {
	row := q.db.QueryRowContext(ctx, getUserForAPIToken, token)
	var i GetUserForAPITokenRow
	err := row.Scan(
		&i.User.ID,
		&i.User.Username,
		&i.User.DisplayName,
		&i.User.FirstName,
		&i.User.LastName,
		&i.User.Extra,
		&i.User.Avatar,
		&i.User.Birthday,
		&i.User.Password,
		&i.User.TotpSecret,
		&i.User.Deleted,
		&i.UserApiToken.ID,
		&i.UserApiToken.Token,
		&i.UserApiToken.Name,
		&i.UserApiToken.UserID,
		&i.UserApiToken.ExpiresAt,
		&i.UserApiToken.CreatedAt,
	)
	return i, err
}

const insertRecoveryCodes = `-- name: InsertRecoveryCodes :exec
INSERT INTO
	mfa_backup_codes (code, user_id)
VALUES
	(?, ?)
`

type InsertRecoveryCodesParams struct {
	Code   string
	UserID string
}

func (q *Queries) InsertRecoveryCodes(ctx context.Context, arg InsertRecoveryCodesParams) error {
	_, err := q.db.ExecContext(ctx, insertRecoveryCodes, arg.Code, arg.UserID)
	return err
}

const isTokenRejected = `-- name: IsTokenRejected :one
SELECT
	COUNT(*) > 0
FROM
	token_invalidation
WHERE
	token_id = ?
`

func (q *Queries) IsTokenRejected(ctx context.Context, tokenID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isTokenRejected, tokenID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const loadUserRecoveryCodes = `-- name: LoadUserRecoveryCodes :many
SELECT
	code, user_id
FROM
	mfa_backup_codes
WHERE
	user_id = ?
`

func (q *Queries) LoadUserRecoveryCodes(ctx context.Context, userID string) ([]MfaBackupCode, error) {
	rows, err := q.db.QueryContext(ctx, loadUserRecoveryCodes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MfaBackupCode
	for rows.Next() {
		var i MfaBackupCode
		if err := rows.Scan(&i.Code, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markRegistrationTokenUsed = `-- name: MarkRegistrationTokenUsed :one
UPDATE
	registration_tokens
SET
	allowed_usage = (
		CASE
			WHEN allowed_usage IS NOT NULL THEN allowed_usage - 1
			ELSE NULL
		END
	)
WHERE
	token = ?
	AND (
		expires IS NULL
		OR expires > ?
	)
RETURNING token, expires, allowed_usage, initial_roles, created_by, created_at
`

type MarkRegistrationTokenUsedParams struct {
	Token   string
	Expires sql.NullTime
}

func (q *Queries) MarkRegistrationTokenUsed(ctx context.Context, arg MarkRegistrationTokenUsedParams) (RegistrationToken, error) {
	row := q.db.QueryRowContext(ctx, markRegistrationTokenUsed, arg.Token, arg.Expires)
	var i RegistrationToken
	err := row.Scan(
		&i.Token,
		&i.Expires,
		&i.AllowedUsage,
		&i.InitialRoles,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const removeAllRecoveryCodes = `-- name: RemoveAllRecoveryCodes :exec
DELETE FROM
	mfa_backup_codes
WHERE
	user_id = ?
`

func (q *Queries) RemoveAllRecoveryCodes(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, removeAllRecoveryCodes, userID)
	return err
}

const revokeUserAPIToken = `-- name: RevokeUserAPIToken :execrows
DELETE FROM user_api_tokens WHERE id = ? AND user_id = ?
`

type RevokeUserAPITokenParams struct {
	ID     string
	UserID string
}

func (q *Queries) RevokeUserAPIToken(ctx context.Context, arg RevokeUserAPITokenParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, revokeUserAPIToken, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const validateRegistrationToken = `-- name: ValidateRegistrationToken :one
SELECT
	COUNT(*) > 0
FROM
	registration_tokens
WHERE
	token = ?
`

func (q *Queries) ValidateRegistrationToken(ctx context.Context, token string) (bool, error) {
	row := q.db.QueryRowContext(ctx, validateRegistrationToken, token)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}
