package selfservice

import (
	"bytes"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"database/sql"
	"encoding/hex"
	"fmt"
	"image/png"
	"math/rand"
	"time"

	"github.com/bufbuild/connect-go"
	"github.com/pquerna/otp/totp"
	idmv1 "github.com/tierklinik-dobersberg/apis/gen/go/tkd/idm/v1"
	"github.com/tierklinik-dobersberg/cis-idm/internal/middleware"
	"github.com/tierklinik-dobersberg/cis-idm/internal/repo"
	"github.com/vincent-petithory/dataurl"
	"golang.org/x/crypto/bcrypt"
)

func (svc *Service) ChangePassword(ctx context.Context, req *connect.Request[idmv1.ChangePasswordRequest]) (*connect.Response[idmv1.ChangePasswordResponse], error) {
	claims := middleware.ClaimsFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("no claims associated with request context")
	}

	user, err := svc.Datastore.GetUserByID(ctx, claims.Subject)
	if err != nil {
		return nil, fmt.Errorf("failed to get user object: %w", err)
	}

	// only verify the old user password if one was actually set.
	if len(user.Password) > 0 {
		if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Msg.GetOldPassword())); err != nil {
			return nil, connect.NewError(connect.CodePermissionDenied, fmt.Errorf("incorrect password"))
		}
	}

	newHashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Msg.GetNewPassword()), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to generate password hash: %w", err)
	}

	rows, err := svc.Datastore.SetUserPassword(ctx, repo.SetUserPasswordParams{ID: claims.Subject, Password: string(newHashedPassword)})
	if err != nil {
		return nil, fmt.Errorf("failed to save user password: %w", err)
	}

	if rows == 0 {
		return nil, fmt.Errorf("user not found")
	}

	return connect.NewResponse(&idmv1.ChangePasswordResponse{}), nil
}

func (svc *Service) Enroll2FA(ctx context.Context, req *connect.Request[idmv1.Enroll2FARequest]) (*connect.Response[idmv1.Enroll2FAResponse], error) {
	claims := middleware.ClaimsFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("no token claims associated with request context")
	}

	user, err := svc.Datastore.GetUserByID(ctx, claims.Subject)
	if err != nil {
		return nil, err
	}

	switch v := req.Msg.Kind.(type) {
	case *idmv1.Enroll2FARequest_TotpStep1:
		if user.TotpSecret.String != "" {
			return nil, connect.NewError(connect.CodeAlreadyExists, fmt.Errorf("totp already enrolled"))
		}

		displayName := user.DisplayName
		if displayName == "" {
			displayName = user.Username
		}

		key, err := totp.Generate(totp.GenerateOpts{
			Issuer:      svc.Config.UserInterface.SiteName,
			AccountName: displayName,
		})
		if err != nil {
			return nil, err
		}

		mac := hmac.New(sha256.New, []byte(svc.Config.JWT.Secret))

		macString := mac.Sum([]byte(key.Secret()))
		macStringHex := hex.EncodeToString(macString)

		img, err := key.Image(200, 200)
		if err != nil {
			return nil, err
		}

		var buf bytes.Buffer
		if err := png.Encode(&buf, img); err != nil {
			return nil, err
		}

		dataUrl := dataurl.EncodeBytes(buf.Bytes())

		return connect.NewResponse(&idmv1.Enroll2FAResponse{
			Kind: &idmv1.Enroll2FAResponse_TotpStep1{
				TotpStep1: &idmv1.EnrollTOTPResponseStep1{
					Secret:     key.Secret(),
					SecretHmac: macStringHex,
					QrCode:     dataUrl,
					Url:        key.String(),
				},
			},
		}), nil

	case *idmv1.Enroll2FARequest_TotpStep2:
		if user.TotpSecret.String != "" {
			return nil, connect.NewError(connect.CodeAlreadyExists, fmt.Errorf("totp already enrolled"))
		}

		// verify that the secret sent in the request was generated by us
		mac := hmac.New(sha256.New, []byte(svc.Config.JWT.Secret))
		macString := mac.Sum([]byte(v.TotpStep2.Secret))
		macStringHex := hex.EncodeToString(macString)
		if macStringHex != v.TotpStep2.SecretHmac {
			return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid secret"))
		}

		// validate the TOTP passcode
		valid := totp.Validate(v.TotpStep2.VerifyCode, v.TotpStep2.Secret)
		if !valid {
			return nil, fmt.Errorf("invalid passcode")
		}

		if err := svc.Datastore.EnrollUserTOTPSecret(ctx, repo.EnrollUserTOTPSecretParams{ID: claims.Subject, TotpSecret: sql.NullString{
			String: v.TotpStep2.Secret,
			Valid:  true,
		}}); err != nil {
			return nil, err
		}

		return connect.NewResponse(&idmv1.Enroll2FAResponse{
			Kind: &idmv1.Enroll2FAResponse_TotpStep2{},
		}), nil

	default:
		return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("requested mfa kind is not available"))
	}
}

func (svc *Service) Remove2FA(ctx context.Context, req *connect.Request[idmv1.Remove2FARequest]) (*connect.Response[idmv1.Remove2FAResponse], error) {
	claims := middleware.ClaimsFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("no token claims associated with request context")
	}

	user, err := svc.Datastore.GetUserByID(ctx, claims.Subject)
	if err != nil {
		return nil, err
	}

	switch v := req.Msg.Kind.(type) {
	case *idmv1.Remove2FARequest_TotpCode:
		if user.TotpSecret.String == "" {
			return nil, connect.NewError(connect.CodeFailedPrecondition, fmt.Errorf("totp 2fa not enrooled"))
		}

		valid := totp.Validate(v.TotpCode, user.TotpSecret.String)
		if !valid {
			// check if the user used a recovery code
			rows, recoveryCodeErr := svc.Datastore.CheckAndDeleteRecoveryCode(ctx, repo.CheckAndDeleteRecoveryCodeParams{UserID: user.ID, Code: v.TotpCode})
			if recoveryCodeErr != nil {

				return nil, recoveryCodeErr
			}

			if rows == 0 {
				return nil, connect.NewError(connect.CodeFailedPrecondition, fmt.Errorf("totp passcode invalid"))
			}
		}

		rows, err := svc.Datastore.RemoveUserTOTPSecret(ctx, claims.Subject)
		if err != nil {
			return nil, err
		}

		if rows == 0 {
			return nil, connect.NewError(connect.CodeFailedPrecondition, fmt.Errorf("user not found"))
		}

	default:
		return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("unsupported mfa type"))
	}

	return connect.NewResponse(&idmv1.Remove2FAResponse{}), nil
}

func (svc *Service) GenerateRecoveryCodes(ctx context.Context, req *connect.Request[idmv1.GenerateRecoveryCodesRequest]) (*connect.Response[idmv1.GenerateRecoveryCodesResponse], error) {
	claims := middleware.ClaimsFromContext(ctx)
	if claims == nil {
		return nil, fmt.Errorf("no token claims associated with request context")
	}

	source := rand.NewSource(time.Now().UnixNano())
	rand := rand.New(source)

	codes := make([]string, 20)
	for i := range codes {
		codes[i] = fmt.Sprintf("%d", rand.Intn(999999-100000)+100000)
	}

	if err := svc.Datastore.RemoveAllRecoveryCodes(ctx, claims.Subject); err != nil {
		return nil, err
	}

	for _, code := range codes {
		if err := svc.Datastore.InsertRecoveryCodes(ctx, repo.InsertRecoveryCodesParams{
			Code:   code,
			UserID: claims.Subject,
		}); err != nil {
			return nil, err
		}
	}

	return connect.NewResponse(&idmv1.GenerateRecoveryCodesResponse{
		RecoveryCodes: codes,
	}), nil
}
